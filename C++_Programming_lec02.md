Lecture 2
=========

p.2 C++
--------
```
• C ++은 C의 확장입니다.
• C ++은 1980 년대 초에 처음 제안되었습니다.
• 객체 지향 프로그래밍에 중점을 둡니다.
  - 데이터 중심 프로그래밍 형식
  - 객체(Object)는 "속성(attributes)"을 가지며 "메소드(method)"를 이해해야 합니다.
• C ++은 진화하는 프로그래밍 언어입니다.
  - 가장 최근의 ISO-accepted 표준은 C ++ 11입니다.
```

p.3 Compiler
------------
```
• 컴파일러는 프로그래밍 언어를 기계어로 바꾸어 준다.
```

p.4 여러 다른 컴파일러들
-------------------
```
• 다양한 C ++ 컴파일러와 통합 개발 환경이 있습니다.
  - GCC (GNU g +) / C ++ 11 지원
  - Clang (LLVM 프로젝트) / C ++ 11 지원
  - 부분적으로 지원되는 Microsoft Visual C ++ / C ++ 11
  - Intel C ++ 컴파일러 / C ++ 11 지원
```

p.5 프로젝트를 위한 C++ 컴파일러
--------------------------
```
• 프로그램을 컴파일하고 실행할 수 있는 한 사용하는 컴파일러 / 개발 환경은 중요하지 않습니다.
• 수업 중 Microsoft Visual C ++ 2013을 사용하십시오.
```

p.6 C ++ 언어 소개
----------------
```
스칼라 변수(Scalar Variables), 연산자(Operators)와 통제 구조(Control Structure)
```

p.7 C ++ 프로그램의 구조
--------------------
```
• C ++ 프로그램은 선언 및 정의 모음입니다.
  - "데이터" 선언 및 정의 (지역 및 전역)
  - "함수" 선언 및 정의
  - "클래스" 선언과 정의 (Object oriented 프로그래밍)
  - "main()"이라는 특수 시작 함수
```

p.8 절차지향 vs 객체지향
-------------------
```
• 절차적 언어는 프로그램을 기능 / 절차 모음으로 표현합니다.
• 객체 지향 언어는 프로그램을 객체 유형 (클래스라고 함)의 모음으로 표현합니다. (다른 디자인 원칙!)
  "C ++은 둘 다!"
• C + + 의 절차적인 측면부터 시작하여 나중에 C ++ 내에서 객체 지향으로 이동합니다.
```

p.9 C++에서의 HelloWorld
-----------------------
```
// Hello World program  ----------> 주석
 
#include <iostream>     ----------> I/O 라이브러리로의 접근을 허용
 
int main()              ----------> 특수 함수 main()의 정의를 시작

{
 
 std::cout << "Hello World\n";   -------> 문자열을 출력
 
 return 0;              -----------> 프로그램이 상태 코드를 반환 (0은 OK를 의미)

}

```

p.10 주석
--------
```
• 주석은 기계어로 변환되지 않은 텍스트를 포함합니다 (인간을 위한 것 입니다).
• "//"다음의 모든 내용은 컴파일러에서 무시됩니다.
• "/ *"와 "* /"사이의 모든 것은 무시됩니다.
```

p.11 주석 예시
------------
```
// Dave 's Homework # 1
//이 프로그램은 굉장합니다!
#include <iostream>
/ *이 프로그램은 우주의 확장 계수를 소수점 이하 27 자리까지 계산합니다.
* /
int main ()
{
cout << 1.0000000000000000000001;
}
```

p.12 C++ 전처리기
---------------
```
• C ++ 컴파일러는 "#include" 문과 기타 특수 지시문을 처리하는 선행 처리기를 자동으로 호출합니다.
• 전 처리기를 실행하기 위해 특별한 작업을 수행 할 필요가 없습니다. 자동으로 처리됩니다.
```

p.13 전처리
-----------
```
• C+ + 프로그램 -> C++ 전처리기 -> 임시파일 (C++프로그램) -> C++ 컴파일러 -> 실행가능한 프로그램
```

p.14 전 처리기 지시문
-----------------
```
• 전처리기 지시문은 컴파일 전에 프로그램 코드를 수정하는 작업인 C 전처리기에 지시를 내리는 명령입니다
• 전처리기 지시문은 항상 "#"문자로 시작합니다. 예 :
#include <표준 헤더 파일>
#define NAME 값
```

p.15 Includes
-------------
```
• 명령문 : "#include <foo.h>"는 컴파일러가 시작되기 전에 파일 내에 foo.h 파일의 내용을 삽입합니다.
• 표준 C ++ 라이브러리를 구성하는 함수와 클래스를 프로그램에서 사용할 수 있도록 하는 정의가 이 파일에 있습니다.
• 자신의 파일을 포함 할 수 있습니다 :
#include < myfile.h >
```

p.16 #define (매크로) 예시  (C heritage)
----------------------------------------
```
#define NUM 45

y = NUM + NUM;

----->  y = 45 + 45; 이 된다
```

p.17 매개 변수화 된 #define (C의 유산)
---------------------------------
```
• C의 매크로 정의 :
  #define 식별자 (식별자, ..., 식별자) token_string
• 매크로 정의 예제 :
  #define SQUARE (x) ((x) * (x))
• 적용:
  SQUARE (i + 2)는 (i + 2) * (i + 2)로 확장됩니다.
```

p.18 일반적인 includes의 예
------------------------
```
• 기본 I / O (C ++) : iostream
• 표준 라이브러리 (C) : stdlib.h
• 시간 및 날짜 지원 (C) : time.h
```

p.19 변수
--------
```
• 변수는 선언 / 정의 되어야합니다.
  예: int i, sum;
  - 변수는 메모리에 있는 위치의 이름입니다.
• 변수에는 타입이 있어야 합니다.
• 변수는 사용하기 전에 선언해야 합니다.
```

p.20 변수(계속)
-------------
```
• 변수는 다음과 같이 선언됩니다 :
  type var_name;
• type은 어떤 종류의 변수인지를 나타냅니다.
• 내장 된 타입은 다음과 같습니다:
  int char float double bool
• 새로운 타입을 생성 할 수도 있습니다. 나중에 더 ...

```

p.21 C++에서의 기본적인 데이터 타입
----------------------------
```
• char ---> 1 바이트, 하나의 문자를 가지고 있을 수 있다.
• int ---> 정수, 보통 호스트 컴퓨터에서 정수의 자연적인 크기를 반영.
• float ---> 단일 정밀점(single precision) 부동 소수점.
• double ---> 더블 정밀점(double precision) 부동 소수점.
• bool ---> 부울방식의 값 (참 또는 거짓)
```

p.22 변수 이름들.
------------------------------
```
• C++ 변수 이름 :
  - 문자, 숫자 그리고 언더스코어로 이루어져 있음.
  - 반드시 숫자가 아닌 것으로 시작해야 한다.
  - 대소문자를 구별한다.
    • foo는 Foo와 다르다.
• 어떠한 길이 던 가능하다.
• 좋은 변수는 읽는이에게 변수가 어떻게 쓰이는지 말해준다.
```

p.23 작은 C++ 프로그램 예시.
------------------------------
```
별 내용 없음.
```

p.24 리터럴들 (상수들)
------------------------------
```
• 상수들은 프로그램에서 쓰이는 고정된 값들 이다.
• 리터럴들의 예시 :
   22 / 3.14159 / 0x2A / false / "Hi Dave" / 'c'
• 선언 시 변수에 값을 할당함으로써 초기화 할 수 있다.
  - int foo = 17;
  - double PI = 3.14159;
  - char c = 'a';
```

p.25 Expressions
------------------------------
```
• C++ expressions는 계산을 표현하기 위해 쓰인다.
• Expressions는 연산자와 연산이 적용되는 피연산자를 포함합니다.
• 피연선자는 변수들, 리터럴들 또는 function call들이 가능하다.
```

p.26 Math expressions
------------------------------
```
• 수학적 표현들은 평가될 때 숫자 값을 가집니다.
• 예시:
  1+2
  (fahr - 32) *(5/9)
  1*(2*(3*(4*5)))
```

p.27 Mathematical Operators
------------------------------
```
• + - * / %
• 연산자는 표현식 평가 방법을 제어하는 우선 순위 및 연관성 규칙을 가지고 있습니다.
• 이 C ++ 표현의 값은 무엇입니까?
  2 / 3 / 4 + 5
• 답변 : 규칙을 알지 못하면 말할 수 없습니다.
```

p.28 Associativity
-------------------
```
• 연산자의 연관성은 동일한 연산자와 관련된 표현식 평가 순서를 제어합니다
  (예 : 3 / 4 / 5
• 연관성은 다음과 같습니다.
  - 왼쪽에서 오른쪽으로 : 가장 왼쪽 연산자가 먼저 적용됩니다.
  - 오른쪽에서 왼쪽으로 : 가장 오른쪽 연산자가 먼저 적용됩니다.
```

p.29 Precedence
------------------
```
• 우선 순위는 연산자 평가 순서를 제어합니다.
- 높은 우선 순위는 낮은 우선 순위 연산자보다 먼저 연산자를 평가 (적용)한다는 의미입니다.
• 동일한 우선 순위를 가진 다른 연산자의 경우 C ++은 왼쪽 첫 번째 연산자를 먼저 계산합니다.
```

p.30 C++ Math Operators Rules
------------------------------
```
연산자      연관성     우선순위
()     왼쪽에서 오른쪽   높음
* / %  왼쪽에서 오른쪽   중간
+ -    왼쪽에서 오른쪽   낮음
```

p.31 관계연산자(Relational Operators)와 항등연산자(Equality Operators)
-----------------------------------------------------------------
```
• 관계 연산자 및 항등 연산자

• 관계를 비교하는 연산자는 값을 비교하는 데 사용됩니다.

• 관계 연산자 : >,> =, <, <=

• 항등 연산자 : ==,! =
```

p.32 관계연산자(Relational Operators)와 항등연산자(Equality Operators)
----------------------------------------------------------------
```
• 관계 연산자는 우선 순위가 매우 낮으며 왼쪽에서 오른쪽으로 연결됩니다.

• 평등 연산자는 매우 낮은 우선 순위를 가지며 왼쪽에서 오른쪽으로 연결됩니다.

• 몇 가지 예 :
  - 17 < x
  - foo == 3.14
  - age ! = 21
  - x + 1 >= 4 * y-z
```

p.33
```
```

p.34
```
```

p.35
```
```

p.36
```
```

p.37
```
```

p.38
```
```

p.39
```
```

p.40
```
```

p.41
```
```

p.42
```
```

p.43
```
```

p.44
```
```

p.45
```
```

p.46
```
```

p.47
```
```

p.48
```
```

p.49
```
```

p.50
```
```

p.51
```
```

p.52
```
```

p.53
```
```

p.54
```
```

p.55
```
```

p.56
```
```

p.57
```
```

p.58
```
```

p.59
```
```

p.60
```
```

p.61
```
```

p.62
```
```

p.63
```
```

p.64
```
```

p.65
```
```

p.66
```
```

p.67
```
```

p.68
```
```

p.69
```
```

p.70
```
```

p.71
```
```

p.72
```
```

p.73
```
```

p.74
```
```

p.75
```
```

p.76
```
```

p.77
```
```

p.78
```
```

p.79
```
```

p.80
```
```
